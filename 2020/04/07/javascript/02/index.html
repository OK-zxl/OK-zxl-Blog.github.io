
<!DOCTYPE html>
<html lang="en">
    <!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <meta name="author" content="Soliton">
  
  
  
  
  
    <link rel="alternate" href="/atom.xml " title="Soliton&#39;s Blog" type="application/atom+xml">
  

  

  <title>数据的类型 | Soliton&#39;s Blog</title>

  

  

  

  <link rel="stylesheet" href="/css/style.css" >
  <link rel="stylesheet" href="/css/partial/dark.css" >

  
  
  

  
    
      <link rel="stylesheet" href="/css/partial/highlight/atom-one-light.css">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/a2396837/CDN@latest/css/iconfont.css">
    
  

  
    <script src="/js/todark.js"></script>
    
<meta name="generator" content="Hexo 5.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
</html>
    
<div class="nav index" style="height: 60px;">
    <div class="title animated fadeInDown">
        <div class="layui-container">
                <div class="nav-title"><a href="/" title="Soliton&#39;s Blog">Soliton&#39;s Blog</a></div>
            <div class="nav-list">
                <button> <span class=""></span><span style="display: block;"></span><span class=""></span> </button>
                <ul class="layui-nav" lay-filter="">
                    
                        
                        
                        
                        
                    <li class="layui-nav-item">
                        <a href="/ ">
                            <i class=" fab fa-fort-awesome " style="color: rgb(255 107 107);"></i>
                            <span class="layui-nav-item-name">首页</span>
                        </a>
                    </li>
                    
                        
                        
                        
                        
                    <li class="layui-nav-item">
                        <a href="/archives/ ">
                            <i class=" fas fa-archive " style="color: rgb(10 189 227);"></i>
                            <span class="layui-nav-item-name">归档</span>
                        </a>
                    </li>
                    
                        
                        
                        
                        
                    <li class="layui-nav-item">
                        <a href="/categories ">
                            <i class=" far fa-folder-open " style="color: rgb(29 209 161);"></i>
                            <span class="layui-nav-item-name">分类</span>
                        </a>
                    </li>
                    
                        
                        
                        
                        
                    <li class="layui-nav-item">
                        <a href="/about/ ">
                            <i class=" fab fa-grav " style="color: rgb(154 106 247);"></i>
                            <span class="layui-nav-item-name">关于</span>
                        </a>
                    </li>
                    
                        
                        
                        
                        
                    <li class="layui-nav-item">
                        <a href="/link/ ">
                            <i class=" fab fa-weixin " style="color: hsl(152deg 73% 45%);"></i>
                            <span class="layui-nav-item-name">友情链接</span>
                        </a>
                    </li>
                    
                    
                        <li class="layui-nav-item" id="btn-toggle-dark">🌙</li>
                    
                    <span class="layui-nav-bar" style="left: 342px; top: 78px; width: 0px; opacity: 0;"></span>
                </ul>
            </div>
        </div>
    </div>
</div>
    
<header class="header">
        
            <div class="title">
                <a href="/">Soliton&#39;s Blog</a>
            </div>
         
    </div>
     

            <div class="motto">
                <span>有志者，事竟成，破釜沉舟，百二秦关终属楚；</span>
            </div>
    
     
</header>

    
<article id="post">
  <div class="post-title">数据的类型</div>
  
<div class="post-meta">
    
    
      <div class="post-meta-item date">
        <span title="Created 2020.04.07"><i class="far fa-calendar-alt"></i> 2020.04.07</span>
      </div>
      <div class="post-meta-item updated">
        <span title="Updated 2022.04.08"><i class="far fa-calendar-check"></i> 2022.04.08</span>
      </div>
     
    
      <div class="post-meta-item categories">
        
          <i class="fas fa-inbox article-meta__icon"></i> <a href="/categories/JavaScript/">JavaScript</a>
        
      </div>
     
    
     <div class="post-meta-item wordcount">
        
          <i class="fas fa-pencil-alt"></i> <span class="post-count">4.8k words</span>
           
        
          <i class="far fa-clock"></i> <span class="post-count">17 min</span>
                               
      </div>
     
</div>


  
  <div class="content">
        <div><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我不知道大家有没有发现，你做前端做了几年之后，突然间再让你复盘一下以前学过的基础知识的时候，你突然会发现自己好像记不太清了，我相信这是很多人的痛点，这时候我欧俄美就需要好好的总结下以前学的东西，并以此作为笔记录下来，只有通过此方法，日后你才会有充足的准备来应对接下来的各种变化。接下来我就来简单的为大家梳理一下以前学过的一些东西</p>
<h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p>我们都知道内存是用来存储数据的空间，而变量又是内存的标识。那么这个数据到底是什么呢？<br>其实这个数据我们可以分为两大类，一是基本类型，又叫值类型，第二种是引用类型，接下来我们就来说说两者具体包含那些<br>一：基本(值)类型<br>    String: 任意字符串<br>    Number: 任意数字<br>    boolean: true/false<br>    undefined: undefined // 已声明未赋值<br>    null: null     // 此类型一般在初始赋值前表明接下来赋值为对象和运算结束后改为垃圾对象被浏览器内的垃圾回收器回收<br>二：引用(对象)类型<br>    Object：任意对象类型<br>    Function: 一种特殊的对象(可执行)<br>    Array: 一种特别的对象(数值下标的集合,内部数据有序的)</p>
<h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><h5 id="基本类型的判断"><a href="#基本类型的判断" class="headerlink" title="基本类型的判断"></a>基本类型的判断</h5><pre><code>    typeof: 返回数据类型的字符串表达 "undefined"/数值/字符串/布尔/function;注意：此API中object与null不能区别、object与array不能区别
    instanceof: 判断对象的具体类型，判断A是不是构造函数B的实例
    ===： 可以判断undefined、null
</code></pre>
<h4 id="引用数据类型的判断"><a href="#引用数据类型的判断" class="headerlink" title="引用数据类型的判断"></a>引用数据类型的判断</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var b1 ={</span><br><span class="line">    b2:[1,'abc',console.log],</span><br><span class="line">    b3:function (){</span><br><span class="line">        console.log('b3)</span><br><span class="line">        return function() {</span><br><span class="line">            return 'js'</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">console.log(b1 instanceof Object, b1 instanceof Array) //true false</span><br><span class="line">console.log(b1.b2 instanceof Array , b1.b2 instanceof Object) //true true</span><br><span class="line">console.log(b1.b3 instanceof Function, b1.b2 instanceof Object) //true true</span><br><span class="line">console.log(typeof b1.b3 === 'function') //true</span><br><span class="line">console.log(typeof b1.b[2] === 'function') //true</span><br><span class="line"></span><br><span class="line">console.log(b1.b3()) //这里返回我们return那个函数，所以我们需要再次通过()来进行调用</span><br><span class="line">console.log(b1.b3()()) //js</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="JS的内存泄露如何检测，场景有哪些"><a href="#JS的内存泄露如何检测，场景有哪些" class="headerlink" title="JS的内存泄露如何检测，场景有哪些"></a>JS的内存泄露如何检测，场景有哪些</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.垃圾回收GC</span><br><span class="line"></span><br><span class="line"> 引用计数（缺陷）、标记清除 </span><br><span class="line"> 闭包严格来说不算内存泄漏，因为是可预期的，产生的数据是不可以被垃圾回收的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> weakMap、weakSet: weakMap 的key只能是引用类型不能是值类型或者字符串类型 </span><br></pre></td></tr></tbody></table></figure>
<h4 id="vdom快吗？"><a href="#vdom快吗？" class="headerlink" title="vdom快吗？"></a>vdom快吗？</h4><p> 1.vdom并不快，js直接操作dom才是最快的<br> 2.但是“数据驱动视图”要有合适的技术方案，不能全部DOM重建<br> 3.vdom就是目前最合适的技术方案（并不是因为快，而是因为合适）<br> 扩展：新出框架svelte用的就不是vdom</p>
<h4 id="遍历数组-for和forEach哪个快？"><a href="#遍历数组-for和forEach哪个快？" class="headerlink" title="遍历数组 for和forEach哪个快？"></a>遍历数组 for和forEach哪个快？</h4><p> 1.for快一点，forEach简洁一点，因为forEach每次都要初始化一个函数去计算，而for不会创建函数<br> 2.函数需要独立的作用域，会有额外的开销</p>
<h4 id="nodejs如何开启进程，进程如何通讯？"><a href="#nodejs如何开启进程，进程如何通讯？" class="headerlink" title="nodejs如何开启进程，进程如何通讯？"></a>nodejs如何开启进程，进程如何通讯？</h4><p> 1.通过child_process模块的fork功能开启，通过on接收，通过send进行通讯<br> 2.cluster模块建立进程集群(集群不超过cpu数量)</p>
<h4 id="请描述jS-Bridge原理"><a href="#请描述jS-Bridge原理" class="headerlink" title="请描述jS Bridge原理"></a>请描述jS Bridge原理</h4><p> JS无法调用native api ，也就是app中的接口，开发者就找到了一些特殊的格式来调用，这些格式就成为js Bridge<br> 1.全局注册API适合于简单的数据通讯 获取版本等等<br> 2.url Scheme自己构建协议标准，推荐</p>
<h4 id="是否了解过requestIdleCallback-和requestAnimationFrame有什么区别？"><a href="#是否了解过requestIdleCallback-和requestAnimationFrame有什么区别？" class="headerlink" title="是否了解过requestIdleCallback?和requestAnimationFrame有什么区别？"></a>是否了解过requestIdleCallback?和requestAnimationFrame有什么区别？</h4><p> 由于react 16版本之后引入了React fiber机制。 什么是fiber？fiber就是将React的虚拟DOM树转换成链表，然后分段渲染，就是渲染时可以暂停可以去执行其他高优任务，空闲时再继续渲染 那么如何判断空闲呢？这时候就要用到requestIdleCallback。<br> requestAnimationFrame是每次渲染都会执行，高优，而requestIdleCallback是空闲时才会执行，低优，且两者都是宏任务</p>
<h4 id="简述一下vue的生命周期"><a href="#简述一下vue的生命周期" class="headerlink" title="简述一下vue的生命周期"></a>简述一下vue的生命周期</h4><p>beforeCraete:创建空白实例，这时候data和method尚未被初始化，不可使用</p>
<p>Created:vue的实例初始化完成，完成响应式绑定，data和method都已经初始化完成，可调用，尚未开始模版渲染</p>
<p>beforeMount:编译模板调用render函数生成vdom,注意，此时还没有进行DOM渲染</p>
<p>mounted:完成DOM渲染，组件创建完成，开始由“创建阶段”进入“运行阶段”</p>
<p>beforeUpdate: data发生变化之后，准备更新DOM  </p>
<p>updated:data发生变化且DOM更新完成，注意：不要在updated中修改数据，会造成死循环</p>
<p>beforeUnmount:组件即将 进入销毁阶段，可移除、解绑全局事件、自定义事件</p>
<p>unmounted:组件被销毁，所有子组件也都被销毁了</p>
<p>PS：<br>在mounted和updated中操作DOM是不能保证子组件全部挂载完成的，使用$nextTick来渲染DOM</p>
<p>ajax在created和mounted两者中都可以请求，推荐mounted</p>
<p>keep-alive组件生命周期<br>onActivated缓存组建被激活<br>onDeactivated缓存组件被隐藏 </p>
<h4 id="Vue2-Vue3-React-三者diff算法有何区别？"><a href="#Vue2-Vue3-React-三者diff算法有何区别？" class="headerlink" title="Vue2 Vue3 React 三者diff算法有何区别？"></a>Vue2 Vue3 React 三者diff算法有何区别？</h4><p>diff算法严格执行的话，时间复杂度为o（n^3）,不可用，<br>所以进行优化就有了Tree diff，主要表现在<br> 1.同级别的比较，不跨层级<br> 2.tag不同则删掉重建不再比较内部细节<br> 3.子节点通过key区别</p>
<p> React diff特点：仅右移<br> 仅右移就是新老vdom数对比如果oldVdom对比newVdom,如果有不同，就把oldVdom往右边移动</p>
<p> vue2 diff特点：双端比较<br> 新老vdom首尾四个指针相互比较，比较完之后往相对方向移动以为继续比较 直至相遇</p>
<p> vue3 diff特点:最长递增子序列<br> 在vue2的基础上增加了最长递增子序列查找法，也就是子序列不变，其他的另外查找插入</p>
<h4 id="Vue的路由有哪几种模式"><a href="#Vue的路由有哪几种模式" class="headerlink" title="Vue的路由有哪几种模式"></a>Vue的路由有哪几种模式</h4><p> 1.hash</p>
<p> 2.history</p>
<p> 3.memoryhistory(v4版本之前叫 Abstrac)</p>
<h4 id="解决手机300ms延迟"><a href="#解决手机300ms延迟" class="headerlink" title="解决手机300ms延迟"></a>解决手机300ms延迟</h4><p> 背景：double tap to zoom</p>
<p> FastClick:原理是监听touchend事件，然后自定义一个DOM事件来模拟click事件，禁止默认的click事件</p>
<p> meta标签中的content属性增加“width=device-width”</p>
<h4 id="网络请求中，token与cookie区别"><a href="#网络请求中，token与cookie区别" class="headerlink" title="网络请求中，token与cookie区别"></a>网络请求中，token与cookie区别</h4><p> cookie：<br> HTTP是无状态的建立完链接，每次请求都要带上cookie，以帮助识别身份，是HTTP规范，和session对应存在，session集中存储用户信息<br> 服务端也可以向客户端set-cookie，cookie的大小限制为4kb<br> 默认有跨域限制，不可跨域共享、传递cookie(跨域传递cookie就是在前端的ajax中设置关键字“withCredentials”)，当主域名相同的时候cookie是可以共享的，也可以设置domain的值为主域名</p>
<p> token:<br>  token自定义传递，需要自己手动存储,且token默认没有跨域限制，让客户端自己存储信息 </p>
<h5 id="两者相比如何？"><a href="#两者相比如何？" class="headerlink" title="两者相比如何？"></a>两者相比如何？</h5><p>  session:<br>  优点：<br>  原理简单、利于学习<br>  用户信息存储在服务端，可快速封禁某个用户<br>  缺点：<br>  占用服务端内存，硬件成本高<br>  多进程多服务器时，不好同步，需借用第三方缓存，如redis </p>
<p>适合有严格管理用户信息的需求的情况下推荐session </p>
<p>  jwt:<br>  优点：<br>  不占用服务器内存，因为他存储在客户端，所以在多进程和多服务器的情况下也不受影响，<br>  没有跨域限制<br>  缺点：<br>  用户信息存储在客户端无法快速封禁用户<br>  万一服务端密钥泄漏的话，则用户信息全部丢失<br>  token体积大于cookie，会增加请求的数据量</p>
<p>  没有特殊要求，则使用jwt</p>
<h4 id="Http1-0-1-1-2-0区别"><a href="#Http1-0-1-1-2-0区别" class="headerlink" title="Http1.0 1.1 2.0区别"></a>Http1.0 1.1 2.0区别</h4><p>  1.0版本:<br>  最基础协议，只支持基本的get post方法</p>
<p>  1.1版本：<br>   增加了缓存策略，支持长链接，支持断点续传，支持新的请求方法，可用于restful API</p>
<p>  2.0版本：<br>  压缩header，减少体积，多路复用(一次链接支持多次并发请求)、支持服务端推送</p>
<h4 id="前端攻击有哪些？分别怎么预防？"><a href="#前端攻击有哪些？分别怎么预防？" class="headerlink" title="前端攻击有哪些？分别怎么预防？"></a>前端攻击有哪些？分别怎么预防？</h4><p>1.<code>点击劫持</code><br>预防：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 第一种方案</span><br><span class="line">if(top.location.hostname != self.location.hostname){</span><br><span class="line">    alert("您正在访问不安全页面，即将跳转到安全页面！")</span><br><span class="line">    top.location.href = self.location.href</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 第二种方案</span><br><span class="line"></span><br><span class="line">将 response headers 中的 X-Frame-Options 设置为 sameorigin</span><br><span class="line">意思是禁止第三方网址加载本站的iframe</span><br></pre></td></tr></tbody></table></figure>
<p>2.<code>DDoS  Distribute denal-of-service 分布式拒绝服务</code></p>
<p>意思就是分布式的大规模的流量访问，使服务器瘫痪<br>预防：<br>因为这种软件层不好预防，就需要硬件层进行预防(例如阿里云WAF )</p>
<p>3.<code>SQL注入</code><br>预防：<br>替换字符</p>
<p>4.<code>XSS</code><br>预防:<br>替换字符</p>
<p>5.<code>CSRF</code><br>预防：</p>
<h4 id="HTTP与Websocket区别"><a href="#HTTP与Websocket区别" class="headerlink" title="HTTP与Websocket区别"></a>HTTP与Websocket区别</h4><p>1.websocket协议名是ws://,可双端发起请求<br>2.websocket没有跨域限制<br>3.websocket是用通过send和onmessage通讯（HTT是通过res和req）<br>ps:ws协议也可以升级为wss </p>
<h4 id="webSocket与HTTP长轮询的区别"><a href="#webSocket与HTTP长轮询的区别" class="headerlink" title="webSocket与HTTP长轮询的区别"></a>webSocket与HTTP长轮询的区别</h4><p>http长轮询：客户端发请求，服务端阻塞不会立即返回<br>webscoket：客户端发请求，服务端也可发起请求</p>
<p>注意PS：长轮询需要处理timeout机制，即timeout之后重新发起请求</p>
<h4 id="描述从输入URL到页面展示的全过程"><a href="#描述从输入URL到页面展示的全过程" class="headerlink" title="描述从输入URL到页面展示的全过程"></a>描述从输入URL到页面展示的全过程</h4><p><code>网络请求</code><br>1.DNS解析域名得到IP，建立TCP链接（三次握手）<br>2.浏览器发送HTTP请求<br>3.收到请求响应得到HTML源代码</p>
<p>PS：<br>1.解析HTML过程中，遇到静态资源还会继续发起网络请求，比如JS、CSS、图片、视频等，如果此时静态资源有强缓存，此时不必请求</p>
<p><code>解析  字符串 &gt; 结构化数据</code><br>1.html形成DOM树<br>2.css形成cssDOM树（style tree）<br>3.两者结合形成Render tree</p>
<p><code>渲染 Render tree 渲染到页面</code><br>1.计算各个DOM的尺寸、定位，最后绘制到页面<br>2.中间可能会执行JS<br>3异步CSS、图片加载，可能会触发页面重新渲染</p>
<h4 id="重绘和重排有什么区别？"><a href="#重绘和重排有什么区别？" class="headerlink" title="重绘和重排有什么区别？"></a>重绘和重排有什么区别？</h4><p>重绘repaint：<br>1.元素外观改变，例如颜色、背景色<br>2.但是元素的尺寸、位定位不变，不会影响其他元素的位置</p>
<p>重排reflow:<br>1.重新计算尺寸和布局，可能会影响其他元素的位置<br>2.如元素的高度增加，可能会使相邻元素往下移动 </p>
<p><code>区别</code><br>重排比重绘影响大，消耗也大，所以尽量避免无意义的重排</p>
<p><code>减少重排的方法</code><br>1.集中修改样式，或切换css class<br>2.修改样式之前先设置<code>display:none</code>,脱离文档流<br>3.使用BFC特性，不影响其他元素位置<br>4.频繁触发的API，使用防抖节流技术<br>5.使用createDocumentFragment批量操作DOM<br>6.优化动画，使用CSS3和requestAnimationFrame </p>
<p>扩展：<code>BFC特性 Block-Format-Context 块级格式化上下文</code></p>
<p>特点：内部元素无论如何改动都不会影响其他元素<br>触发条件：<br>1.根结点<br>2.float:left/right<br>3.overflow:auto/scroll/hidden<br>4.display:inline-block/table/table-row/table-cell<br>5.display:flex/grid的直接子元素<br>6.position:absolute/fixed </p>
<h4 id="如何实现网页多标签通讯"><a href="#如何实现网页多标签通讯" class="headerlink" title="如何实现网页多标签通讯"></a>如何实现网页多标签通讯</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">方案一：</span><br><span class="line">使用websocket</span><br><span class="line">原因：</span><br><span class="line">无跨域限制、但是需要服务端支持、成本高 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案二</span><br><span class="line">使用localStorage通讯</span><br><span class="line">原因：</span><br><span class="line">可以进行同域之间的两个页面的通讯，当然localStorage也是跨域不共享</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案三</span><br><span class="line">使用sharedWorker，sharedworker是webworker的一种，webworker是可以开启子进程执行JS，但是不能操作DOM</span><br><span class="line">所以就使用sharedWorker单独开启一个子进程，用于同域页面的通讯</span><br><span class="line">缺点：</span><br><span class="line">调试不方便，不兼容IE11</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="实现网页与iframe之间的通讯"><a href="#实现网页与iframe之间的通讯" class="headerlink" title="实现网页与iframe之间的通讯"></a>实现网页与iframe之间的通讯</h4><p>使用postMessage通讯，注意跨域的限制和判断</p>
<h4 id="描述koa2洋葱圈模型"><a href="#描述koa2洋葱圈模型" class="headerlink" title="描述koa2洋葱圈模型"></a>描述koa2洋葱圈模型</h4><p>koa2<br>一个简约的、流行的nodejs框架<br>通过中间件组织代码<br>多个中间件以“洋葱圈模型”执行，一层包一层</p>
<h4 id="h5页面如何进行首屏优化？"><a href="#h5页面如何进行首屏优化？" class="headerlink" title="h5页面如何进行首屏优化？"></a>h5页面如何进行首屏优化？</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">方案一</span><br><span class="line">路由懒加载</span><br><span class="line">适用于SPA（不适用MPA）</span><br><span class="line"></span><br><span class="line">路由拆分，优先保证首页加载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案二</span><br><span class="line">服务端渲染SSR</span><br><span class="line">传统前后端分离（SPA）渲染页面的过程复杂</span><br><span class="line">SSR渲染页面过程简单，所有性能好</span><br><span class="line">如果是纯H5页面，SSR是性能优化的终极方案</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案三</span><br><span class="line">app预取</span><br><span class="line">如果H5在app webview中展示，可使用pp预取</span><br><span class="line">用户访问列表页时，App预加载文章首屏内容、用户进入H5时直接从App中获取内容，瞬间展示内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案四</span><br><span class="line">分页</span><br><span class="line">针对列表页</span><br><span class="line"></span><br><span class="line">方案五</span><br><span class="line">lazyload 图片懒加载</span><br><span class="line">针对详情页</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案六</span><br><span class="line">Hybrid</span><br><span class="line">提前将HTML CSS JS下载到app内部</span><br><span class="line">然后在app webview中使用file://协议加加载页面文件</span><br><span class="line">再用ajax获取内容并展示</span><br></pre></td></tr></tbody></table></figure>
<h4 id="后端一次性返回10W条数据，你该如何渲染？"><a href="#后端一次性返回10W条数据，你该如何渲染？" class="headerlink" title="后端一次性返回10W条数据，你该如何渲染？"></a>后端一次性返回10W条数据，你该如何渲染？</h4><p>首页设计不合理没有后端一次性返回10W条数据，首页返回10w条数据渲染是个问题，加载也需要一个过程</p>
<p>如果真的要达到这个效果，那么可以用如下方法<br>1.自定义nodeJS中间层，获取并拆分10w条数据，但是成本还是比较高的</p>
<p>2.虚拟列表，只渲染可视区域的DOM，其他隐藏区域不显示，只用div容器撑起来就可以了，且随着浏览器的滚动对DOM进行创建和销毁。但是虚拟列表非常麻烦，最好是借用第三方lib（例如Vue的vue-virtual-scroll-list，React的vue-virtualiszd）</p>
<h4 id="前端常用的设计模式有哪些？并说明使用场景"><a href="#前端常用的设计模式有哪些？并说明使用场景" class="headerlink" title="前端常用的设计模式有哪些？并说明使用场景"></a>前端常用的设计模式有哪些？并说明使用场景</h4><p>设计原则最重要的思想:开放封闭原则，也就是对扩展开放，对修改封闭 </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//工厂模式</span><br><span class="line">用一个工厂函数来创建实例，隐藏new。例如JQ的$函数、React的createElement函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//单例模式</span><br><span class="line">全局唯一的实例（无法生成第二个），如Vuex Redux的store，还有全局唯一的dialog、modal</span><br><span class="line">JS是单线程的，创建单例很简单</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//代理模式</span><br><span class="line">使用者不能直接访问对象，而是访问一个代理层</span><br><span class="line">在代理层可以监听get、set做很多事情，例如ES6的Prox实现的Vue3响应式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//观察者模式</span><br><span class="line">一个主题、一个观察者，主题变化之后触发观察者执行</span><br><span class="line">例如`btn.addEventListener('click',()=&gt;{...})``</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//发布订阅</span><br><span class="line">event.on('key',()=&gt;{</span><br><span class="line">    //事件1</span><br><span class="line">})</span><br><span class="line">event.on('key',()=&gt;{</span><br><span class="line">    //事件2</span><br><span class="line">})</span><br><span class="line">event.emit('key')</span><br><span class="line"></span><br><span class="line">PS:绑定的事件一定要记得删除，防止内存泄漏</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//装饰器模式</span><br><span class="line">原功能不变，增加一些新功能（AOP面向切面编程），包括类装饰器，方法装饰器 </span><br><span class="line">例如ES和TS的Decorator语法</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="观察者模式和发布订阅者模式的区别？"><a href="#观察者模式和发布订阅者模式的区别？" class="headerlink" title="观察者模式和发布订阅者模式的区别？"></a>观察者模式和发布订阅者模式的区别？</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">观察者模式：一个主题绑定一个监听，直接触发事件 ，Subject与Obsrver是直接绑定的，没有中间媒介</span><br><span class="line"></span><br><span class="line">发布订阅模式：它有一个自定义事件，Pubisher与Subscriber是不认识的，需要中间媒介 Event Channel来进行串联 </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h4 id="实际生活中，做过哪些Vue的优化？"><a href="#实际生活中，做过哪些Vue的优化？" class="headerlink" title="实际生活中，做过哪些Vue的优化？"></a>实际生活中，做过哪些Vue的优化？</h4> <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">v-if和v-show</span><br><span class="line">大部分情况下使用v-if就好了，不需要过度优化</span><br><span class="line"></span><br><span class="line">v-for使用key</span><br><span class="line"></span><br><span class="line">使用computed缓存 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">keep-alive缓存组件 </span><br><span class="line">频繁切换，例如tabs，但是不要乱用，缓存太多会占用内存，且不好debug</span><br><span class="line"></span><br><span class="line">异步组件</span><br><span class="line">针对体积比较大的组件，例如编辑器、复杂表单这样的，可以进行拆包，需要时进行异步加载，不需要时不加载，有利于减少主包体积，首页模块加载的会更快 </span><br><span class="line"></span><br><span class="line">路由懒加载</span><br><span class="line">项目较大时，路由拆分，保证首页优先加载</span><br><span class="line"></span><br><span class="line">服务端渲染</span><br><span class="line">但是成本较高 </span><br></pre></td></tr></tbody></table></figure>
<h4 id="使用Vue遇到过哪些坑"><a href="#使用Vue遇到过哪些坑" class="headerlink" title="使用Vue遇到过哪些坑"></a>使用Vue遇到过哪些坑</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">内存泄漏</span><br><span class="line">全局变量、全局事件、全局定时器、自定义事件没有及时销毁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue2响应式缺陷</span><br><span class="line">例如：data新增属性需要用Vue.set，删除属性时需要用Vue.delete</span><br><span class="line">无法直接修改数组，必须通过arr[index] = value </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">路由切换时,scroll到顶部</span><br><span class="line">这是一个SPA的通病不仅仅是Vue </span><br><span class="line">解决办法就是缓存数据和scrollTop的值，再次返回时渲染数据，执行ScrollTo(xx)</span><br><span class="line">终极解决方案是：MPA+App Webview</span><br></pre></td></tr></tbody></table></figure>
<h4 id="实际生活中，做过哪些React优化"><a href="#实际生活中，做过哪些React优化" class="headerlink" title="实际生活中，做过哪些React优化"></a>实际生活中，做过哪些React优化</h4><p>1.循环使用key<br>2.使用Fragment减少层级<br>3.JSX中不要去定义函数<br>4.要在构造函数中bind this<br>5.使用shouldComponentUpdate判断组件是否要更新，或者直接使用React.PureComponent,亦或者React.memo<br>6.HOOKS缓存数据（useMemo）和函数（useCallback ）</p>
<h4 id="使用React过程中遇到过哪些坑？"><a href="#使用React过程中遇到过哪些坑？" class="headerlink" title="使用React过程中遇到过哪些坑？"></a>使用React过程中遇到过哪些坑？</h4><p>1.自定义组件的名称要首字母大写<br>2.JS关键词冲突 // for 要改成htmlFor，class要改成className<br>3.JSX数据类型 //用{}表示变量，用””表示字符串<br>4.setState是异步更新的 </p>
<h4 id="如何统一监听Vue组件报错"><a href="#如何统一监听Vue组件报错" class="headerlink" title="如何统一监听Vue组件报错"></a>如何统一监听Vue组件报错</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">方案一</span><br><span class="line">window.onerror</span><br><span class="line">全局监听所有JS错误</span><br><span class="line">但它是JS级别的，不能监听Vue组件信息报错</span><br><span class="line">会捕捉到一些vue监听不到的错误 </span><br><span class="line"> // window.onerror = function (msg, source, line, column, error) {</span><br><span class="line"> //     console.info('window.onerror----', msg, source, line, column, error)</span><br><span class="line"> //   }</span><br><span class="line"></span><br><span class="line">方案二</span><br><span class="line">errorCaptrued</span><br><span class="line">监听Vue错误的生命周期，监听所有下级组件的错误</span><br><span class="line">返回false会阻止向上传播</span><br><span class="line"> // errorCaptured: (err, vm, info) =&gt; {</span><br><span class="line"> //    console.info('errorCaptured----', err, vm, info)</span><br><span class="line"> //    // return false</span><br><span class="line"> //  },</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 方案三</span><br><span class="line"> errorHandler配置</span><br><span class="line"> Vue全局对错误监听，所有组件错误都会汇总到这里</span><br><span class="line"> 但是errorCaptrued返回false，不会传播到这里</span><br><span class="line"> // app.config.errorHandler = (error, vm, info) =&gt; {</span><br><span class="line"> //    console.info('errorHandler----', error, vm, info)</span><br><span class="line"> // }</span><br><span class="line">PS：在异步回调里的错误，errorHandler监听不到，只能结合window.onerror进行实现</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="如何统一监听React组件报错"><a href="#如何统一监听React组件报错" class="headerlink" title="如何统一监听React组件报错?"></a>如何统一监听React组件报错?</h4><p>React 16之后Error 增加了ErrorBoundray组件<br>该组件监听所有下级组件的报错，可降级展示UI<br>只监听组件渲染时报错，不监听DOM事件、异步错误<br>只在pro环境生效，dev环境直接报错</p>
<p>监听事件报错可用try-catch或者window.onerror</p>
<h4 id="如果一个H5很慢，你会如何该如何去排查性能问题？"><a href="#如果一个H5很慢，你会如何该如何去排查性能问题？" class="headerlink" title="如果一个H5很慢，你会如何该如何去排查性能问题？"></a>如果一个H5很慢，你会如何该如何去排查性能问题？</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">前端性能指标</span><br><span class="line">1.First Paint(FP) // 第一次渲染 ，开始发生变化了</span><br><span class="line">2.First Contentful Paint(FCP) // 第一次有内容的渲染</span><br><span class="line">3.DomContentLoaded(DCL) // 页面DOM加载完成</span><br><span class="line">4.Largest Contentfull Paint(LCP) // 页面最大的内容渲染完成</span><br><span class="line">5.Load // 加载</span><br><span class="line">方案一</span><br><span class="line">Chrome denTools</span><br><span class="line"> Performance:可查看上述性能指标并有网页快照</span><br><span class="line"> Network:可以查看到各个资源加载的时间</span><br><span class="line"> lightouse:性能评测工具</span><br></pre></td></tr></tbody></table></figure>
<h4 id="工作中遇到的难题"><a href="#工作中遇到的难题" class="headerlink" title="工作中遇到的难题"></a>工作中遇到的难题</h4><p>描述问题：背景、现象、造成的影响<br>解决问题：分析+解决<br>成长：学到了什么以后如何避免 </p>
<h3 id="手写代码题"><a href="#手写代码题" class="headerlink" title="手写代码题"></a>手写代码题</h3><p>最后一个题外话：我们如何区分数据类型和变量类型呢？</p>
</div>
        
  </div>

    <div class="post_tags">
      
    </div>
    <div class="post-nav">
      
        <div class="post-nav-prev post-nav-item">
            <a href="/2020/04/07/browser/browser1/" >多浏览器兼容问题<i class="fa fa-chevron-left"></i></a>
        </div>
      
      
        <div class="post-nav-next post-nav-item">
            <a href="/2020/04/07/javascript/curry/" >函数式编程的柯里化<i class="fa fa-chevron-right"></i></a>
        </div>
      
    </div>
      




</article>

    
<a id="gotop" href="javascript:" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    






    
<div id="bottom-outer">
    <div id="bottom-inner">
        © 2020 <i class="fa fa-heart" id="heart"></i> Soliton 
        <br>
        Powered by 
        <a target="_blank" rel="noopener" href="http://hexo.io">hexo</a> | Theme is <a target="_blank" rel="noopener" href="https://github.com/a2396837/hexo-theme-blank/">blank</a>
        
          <div class="icp-info">
            
          <a href="" target="_blank"> </a>
        </div>
        
    </div>  
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/layui-src@2.5.5/dist/layui.min.js"></script>



  
    <script src="/js/script.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script>
  

 

  <script src="/js/local-search.js"></script>
<script type="text/javascript">      
  var search_path = "search.xml";
if (search_path.length == 0) {
  search_path = "search.xml";
}
var path = "/" + search_path;
  searchFunc(path, 'local-search-input', 'local-search-result');
</script>
  


  <script>
    window.lazyLoadOptions = {
      elements_selector: 'img',
      threshold: 0
    }
</script>
<script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script>   
  


  <script>
    var images = $('img').not('.nav-logo img').not('.card img').not($('a>img')).not('.reward-content img')
    images.each(function (i, o) {
      var lazyloadSrc = $(o).attr('data-src') ? $(o).attr('data-src') : $(o).attr('src')
      $(o).wrap(`<a href="${lazyloadSrc}" data-fancybox="group" data-caption="${$(o).attr('alt')}" class="fancybox"></a>`)
    })
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script>
  <script>
        $().fancybox({
      selector: '[data-fancybox]',
      loop: true,
      transitionEffect: 'slide',
      protect: true,
      buttons: ['slideShow', 'fullScreen', 'thumbs', 'close']
    })
  </script>   
  










  <script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script>
  




  
<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js"></script>
<script>
!function (e, t, a) {
  var initCopyCode = function(){
    var copyHtml = '';
    copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
    copyHtml += '  <i class="fa fa-clipboard"></i><span>复制</span>';
    copyHtml += '</button>';
    $(".highlight .code pre").before(copyHtml);
    new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
  }
  initCopyCode();
}(window, document);
</script>  
  

<script>
  var btntop = $('#gotop');
  btntop.on('click', function (e) {
    e.preventDefault();
    $('html, body').animate({ scrollTop: 0 }, '300');
  });

  var $table = $('.content table').not($('figure.highlight > table'))
$table.each(function () {
  $(this).wrap('<div class="table-wrap"></div>')
})
</script>



</html>